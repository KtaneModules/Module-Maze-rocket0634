using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class ModuleMazeModule : MonoBehaviour
{
    private static int _moduleIDCounter = 1;
    private int _moduleID;
    public KMBombInfo Info;
    public KMBombModule Module;
    public KMAudio Audio;
    public KMRuleSeedable RuleSeedable;
    public SpriteRenderer IconHolder, IconHolder2;
    public Sprite[] sprites, gSprites, souvenirSprites;
    public KMSelectable[] Buttons;
    public TextAsset selections;
    public string souvenirStart = "empty", version;
    internal Dictionary<string, ModuleInfo> assignments = new Dictionary<string, ModuleInfo>();
    private Dictionary<int, string> orderedInfo;

    public int y, size, pixelsPerUnit;
    //The index value for the starting bomb
    //The index value for the destination bomb
    private int start, destination;
    private int[] phonies = new int[5];
    float t;
    private Queue<IEnumerable> queue = new Queue<IEnumerable>();
    //Keep track of when the module is processing an input (don't process any others while ready is false) |
    //Don't allow interactions when !_isActive or solved 
    private bool ready = true, _isActive = false, solved, showSolution = true, first = true;

    // Use this for initialization
    void Start()
    {
        _moduleID = _moduleIDCounter++;
        var text = selections.text;
        var settingsPath = System.IO.Path.Combine(Application.persistentDataPath, "Modsettings");
        var path = System.IO.Path.Combine(settingsPath, "ModuleMazeConnections.txt");
        var write = false;
        var readText = "";
        if (!System.IO.File.Exists(path) || System.IO.File.ReadAllText(path).Length == 0) write = true;
        else readText = System.IO.File.ReadAllText(path);
        if (write || readText.Substring(9, 1) != version)
            System.IO.File.WriteAllText(path, string.Format("Version: {0} - Do not edit this file in Windows Notepad\n" +
                "This file may be used to modify icon connections in Module maze.\n" +
                "Only down,right movements are recorded.\n{1}", version, selections.text));
        else if (readText.Substring(9, 1) == version)
        {
            text = readText.Substring(readText.IndexOf("\n") + 1);
            text = text.Substring(text.IndexOf("\n") + 1);
            text = text.Substring(text.IndexOf("\n") + 1);
        }
        TextReader.Run(this, text);
        orderedInfo = assignments.Where(x => x.Value.index != -1).ToDictionary(x => x.Value.index + 1, y => y.Key);
        /*if (RuleSeedable.GetRNG().Seed != 1)
        {
            
        } else {*/
            start = UnityEngine.Random.Range(1, sprites.Length);
            Func<int, bool> func = (z) => z == start || !Distance();
            destination = UnityEngine.Random.Range(1, sprites.Length);
            while (func(destination)) destination = UnityEngine.Random.Range(1, sprites.Length);
            for (int i = 0; i < phonies.Count(); i++)
            {
                while (phonies[i] == start || (i > 0) && phonies.Take(i).Contains(phonies[i]) || phonies[i] == 0)
                    phonies[i] = UnityEngine.Random.Range(1, sprites.Length);
            }
        //}
        IconHolder.sprite = sprites[destination];
        for (int i = 0; i < Buttons.Length; i++)
        {
            int j = i;
            Buttons[i].OnInteract = ButtonHandler(j);
        }
        Module.OnActivate += delegate ()
        {
            DebugLog("Expected icon is {0}", sprites[destination].name);
            _isActive = true;
        };
        StartCoroutine(WaitForInput());
    }

    bool Distance()
    {
        var current = orderedInfo[start];
        var endingKey = orderedInfo[destination];
        if (!Loop(current, 0, 24, true, endingKey, new List<string>())) return true;
        else return false;
    }

    bool Loop(string current, int count, int countLimit, bool doCount, string end, List<string> path)
    {
        for (int i = 0; i < 4; i++)
        {
            var next = assignments[current].connections[i];
            if (next != null && ((doCount && count < countLimit) || !doCount) && next != end && !path.Contains(next))
            {
                if (!path.Contains(current)) path.Add(current);
                if (Loop(next, count + 1, countLimit, doCount, end, path)) return true;
            }
            else if (next == end)
            {
                DebugLog("Distance is {0} movements", !doCount, count + 1);
                return true;
            }
            else continue;
        }
        return false;
    }

    KMSelectable.OnInteractHandler ButtonHandler(int i)
    {
        return delegate ()
        {
            //if (solved) return false;
            /* Reset isn't necessary here.
             * if (i == 4 && !showSolution)
            {
                var coroutine = Count();
                StartCoroutine(coroutine);
                Buttons[4].OnInteractEnded = delegate
                {
                    StopCoroutine(coroutine);
                    if (t < 2) queue.Enqueue(ButtonPress(4));
                    Buttons[4].OnInteractEnded = null;
                };
                return false;
            }*/
            if (!_isActive || solved) return false;
            Buttons[i].AddInteractionPunch(0.5f);
            Audio.PlayGameSoundAtTransform(KMSoundOverride.SoundEffect.ButtonPress, transform);
            queue.Enqueue(ButtonPress(i));
            return false;
        };
    }

    private IEnumerator Count()
    {
        t = 0f;
        while (isActiveAndEnabled)
        {
            yield return t += Time.deltaTime;
            if (t > 2.0f) break;
        }
        queue.Enqueue(ButtonPress(5));
    }

    private IEnumerator WaitForInput()
    {
        do
        {
            yield return null;
            if (queue.Count > 0)
            {
                IEnumerable press = queue.Dequeue();
                foreach (object item in press) yield return item;
            }
        }
        while (ready);
    }

    IEnumerable ButtonPress(int i)
    {
        var oP = IconHolder.transform.localPosition;
        var cP = start;
        var rP = IconHolder.transform.localPosition;
        var move = "";
        ready = false;
        var strike = true;
        if (showSolution && i != 4)
        {
            Audio.PlayGameSoundAtTransform(KMSoundOverride.SoundEffect.Strike, transform);
            ready = true;
            yield break;
        }
        switch (i)
        {
            case 0:
                move = "top";
                oP.z -= 1.1f;
                rP.z += 1.1f;
                if (assignments[orderedInfo[start]].connections[3] != null)
                {
                    start -= y;
                    strike = false;
                }
                break;
            case 1:
                move = "right";
                oP.x -= 1.1f;
                rP.x += 1.1f;
                if (assignments[orderedInfo[start]].connections[2] != null)
                {
                    start++;
                    strike = false;
                }
                break;
            case 2:
                move = "bottom";
                oP.z += 1.1f;
                rP.z -= 1.1f;
                if (assignments[orderedInfo[start]].connections[1] != null)
                {
                    start += y;
                    strike = false;
                }
                break;
            case 3:
                move = "left";
                oP.x += 1.1f;
                rP.x -= 1.1f;
                if (assignments[orderedInfo[start]].connections[0] != null)
                {
                    start--;
                    strike = false;
                }
                break;
            case 4:
                if (start == destination && !showSolution)
                {
                    solved = true;
                    try
                    {
                        souvenirSprites = new[] { gSprites.Where(x => x.name == souvenirStart).First(), gSprites.Where(x => x.name == sprites[phonies[0]].name).First(), gSprites.Where(x => x.name == sprites[phonies[1]].name).First(), gSprites.Where(x => x.name == sprites[phonies[2]].name).First(), gSprites.Where(x => x.name == sprites[phonies[3]].name).First(), gSprites.Where(x => x.name == sprites[phonies[4]].name).First() };
                    }
                    catch
                    {
                        DebugLog("There was an issue with randomization. If Souvenir support is active, it may be impacted.");
                        DebugLog("Chosen Indicies: {0}, resulting names: {1}", false, string.Join(", ", phonies.Select(x => x.ToString()).ToArray()), string.Join(", ", phonies.Select(x => sprites[x].name).ToArray()));
                        DebugLog("Starting name: {0}", false, souvenirStart);
                    }
                    Module.HandlePass();
                }
                else if (showSolution)
                {
                    IconHolder.sprite = sprites[start];
                    DebugLog("Shown icon is {0}", sprites[start].name);
                    if (first)
                    {
                        souvenirStart = sprites[start].name;
                        first = !first;
                    }
                    showSolution = !showSolution;
                    ready = true;
                }
                else
                {
                    Module.HandleStrike();
                    DebugLog("Strike obtained, showing solution icon.");
                    IconHolder.sprite = sprites[destination];
                    showSolution = !showSolution;
                    ready = true;
                }
                break;
            /*case 5:
                var coroutine = AutoSolve(start, true);
                while (coroutine.MoveNext())
                    yield return coroutine.Current;
                break;*/
        }
        if (i > 3) yield break;
        yield return MoveScreen(oP, rP, cP, move, strike);
        yield return null;
    }

    IEnumerator MoveScreen(Vector3 bh1, Vector3 bh2O, int oP, string m, bool strike = false)
    {
        var t = 0.0f;
        var duration = 0.25f;
        IconHolder2.transform.localPosition = bh2O;
        IconHolder2.sprite = null;
        var b = IconHolder.transform.localPosition;
        if (strike)
        {
            duration /= 2;
            bh1.x /= 2;
            bh1.z /= 2;
            while (t < duration)
            {
                yield return null;
                t = Mathf.Min(t + Time.deltaTime, duration);
                IconHolder.transform.localPosition = Vector3.Lerp(b, bh1, Mathf.SmoothStep(0.0f, 1.0f, t / duration));
                IconHolder2.transform.localPosition = Vector3.Lerp(bh2O, b, Mathf.SmoothStep(0.0f, 1.0f, t / duration));
            }
            Module.HandleStrike();
            //Clear the queue for TP Compatibility
            queue.Clear();
            DebugLog("Wall detected to the {1} from {0}", sprites[start].name, m);
            t = 0;
            while (t < duration)
            {
                yield return null;
                t = Mathf.Min(t + Time.deltaTime, duration);
                IconHolder.transform.localPosition = Vector3.Lerp(bh1, b, Mathf.SmoothStep(0.0f, 1.0f, t / duration));
                IconHolder2.transform.localPosition = Vector3.Lerp(b, bh2O, Mathf.SmoothStep(0.0f, 1.0f, t / duration));
            }
            ready = true;
            yield break;
        }
        var move = m;
        switch (m)
        {
            case "top":
                move = "up";
                break;
            case "bottom":
                move = "down";
                break;
        }
        IconHolder2.sprite = sprites[start];
        while (t < duration)
        {
            yield return null;
            t = Mathf.Min(t + Time.deltaTime, duration);
            IconHolder.transform.localPosition = Vector3.Lerp(b, bh1, Mathf.SmoothStep(0.0f, 1.0f, t / duration));
            IconHolder2.transform.localPosition = Vector3.Lerp(bh2O, b, Mathf.SmoothStep(0.0f, 1.0f, t / duration));
        }
        DebugLog("Moved {0} from icon [{1}] to [{2}]", move, sprites[oP].name, sprites[start].name);
        IconHolder.sprite = sprites[start];
        IconHolder.transform.localPosition = new Vector3(0, 0.55f, 0);
        IconHolder2.transform.localPosition = bh2O;
        yield return null;
        ready = true;
    }

    bool StartsWithOrEndsWithAny(string source, params string[] strings)
    {
        foreach (string str in strings)
        {
            if (source.StartsWith(str) || source.EndsWith(str)) return true;
        }
        return false;
    }

    string ReplaceAll(string source, string result, params string[] strings)
    {
        foreach (string str in strings)
        {
            source = source.Replace(str, result);
        }
        return source;
    }

    private string TwitchHelpMessage = "Interact with the module using !{0} udlr NSEW, and use !{0} toggle to interact with the screen.";

    private IEnumerator ProcessTwitchCommand(string input)
    {
        input = input.ToLowerInvariant();
        var submit = false;
        var presses = new List<KMSelectable>();
        /* You'll always know where you are in the maze, as such there is no need for a reset.
         * if (StartsWithOrEndsWithAny(input, "reset"))
        {
            yield return null;
            Buttons.Last().OnInteract();
            yield return new WaitForSeconds(2.1f);
            Buttons.Last().OnInteractEnded();
            yield break;
        }*/
        if (StartsWithOrEndsWithAny(input, "submit", "select", "toggle"))
        {
            Debug.LogFormat(input);
            submit = true;
            input = ReplaceAll(input, "", "submit", "select", "toggle");
        }
        input = input.Replace("press", "");
        foreach (char c in input)
        {
            switch (c)
            {
                case 'u':
                case 'n':
                    presses.Add(Buttons[0]);
                    break;
                case 'r':
                case 'e':
                    presses.Add(Buttons[1]);
                    break;
                case 'd':
                case 's':
                    presses.Add(Buttons[2]);
                    break;
                case 'l':
                case 'w':
                    presses.Add(Buttons[3]);
                    break;
                case ' ':
                    break;
                default:
                    yield break;
            }
        }
        if (submit) presses.Add(Buttons[4]);
        yield return null;
        yield return presses.ToArray();
        //Focus on the module until the queue is empty
        //This is so solves and strikes are detected properly
        yield return new WaitUntil(() => queue.Count == 0);
    }

    IEnumerator TwitchHandleForcedSolve()
    {
        while (!ready)
            yield return true;
        var coroutine = AutoSolve(destination);
        while (coroutine.MoveNext())
        {
            yield return coroutine.Current;
            yield return true;
        }
    }

    IEnumerator AutoSolve(int curDest)
    {
        //if (!reset) 
        if (showSolution) Buttons[4].OnInteract();
        yield return null;
        var curLoc = start;
        var step = 0;
        if (curLoc == curDest)// && !reset)
        {
            Buttons[4].OnInteract();
            yield break;
        }
        /*else if (curLoc == curDest)
        {
            DebugLog("You reset from your current location to your current location.");
            ready = true;
            queue.Clear();
            yield break;
        }*/
        var list = new List<string>();
        var end = false;
        var str = "";
        var movements = new Stack<int>();
        var direction = 0;
        var dirCount = 0;
        var explored = new List<int>();
        list.Add("[0, -1, " + curLoc + ", 0]");
        var directions = new int[] { -1, y, 1, -y };
        while (!end)
        {
            var curStep = step;
            if (assignments[orderedInfo[curLoc]].connections[direction] != null && !explored.Contains(curLoc + directions[direction]))
            {
                if (!movements.Contains(curLoc + directions[direction]))
                {
                    str += direction;
                    movements.Push(curLoc);
                    step++;
                    curLoc += directions[direction];
                    if (curLoc == curDest)
                        end = true;
                    list.Add(string.Format("[{0}, {1}, {2}, {3}]", str, step, curLoc, dirCount));
                    direction = 0;
                }
                else direction++;
            }
            else
                direction++;
            if (direction > 3 && curStep == step && step != 0)
            {
                while (direction > 3 && step > 0)
                {
                    step--;
                    explored.Add(curLoc);
                    curLoc += directions[(str.Last() - '0' + 2) % 4];
                    direction = str.Last() - '0' + 1;
                    str = str.Length > 1 ? str.Substring(0, str.Count() - 1) : "";
                    movements.Pop();
                }
            }
            if (direction > 3 && str.Length == 0)
                end = true;
            direction %= 4;
            /* Hopefully this won't be needed.
            dirCount++;
            if (!timer.Enabled)
            {
                DebugLog("Error.", false);
                DebugLog(str, false);
                DebugLog("{0} - {1}", false, y, start);
                DebugLog(movements.Count + ": " + string.Join("-", movements.Select(x => sprites[x].name).ToArray()), false);
                DebugLog(string.Join("\n", list.ToArray()), false);
                DebugLog(string.Join(", ", explored.Select(x => x.ToString()).ToArray()));
                yield break;
            }*/
        }
        foreach (char c in str)
        {
            var notC = c - '0';
            var selectables = new[] { Buttons[3], Buttons[2], Buttons[1], Buttons[0] };
            ready = true;
            yield return null;
            selectables[notC].OnInteract();
        }
        /*if (reset)
        {
            DebugLog("Returned to starting location.");
            ready = true;
            yield break;
        }*/
        yield return new WaitUntil(() => queue.Count == 0 && ready);
        if (curDest != destination)
        {
            var coroutine = AutoSolve(destination);
            while (coroutine.MoveNext())
                yield return coroutine.Current;
            yield break;
        }
        yield return null;
        Buttons[4].OnInteract();
        //Buttons[4].OnInteractEnded();
    }

    void DebugLog(string log, params object[] args)
    {
        DebugLog(log, true, args);
    }

    void DebugLog(string log, bool show, params object[] args)
    {
        var logData = string.Format(log, args);
        var name = Module.ModuleDisplayName + " #" + _moduleID;
        var showText = show ? string.Format("[{0}]", name) : string.Format("<{0}>", name);
        Debug.LogFormat("{0} {1}", showText, logData);
    }
}

public class ModuleInfo
{
    public Sprite sprite;
    public int index = -1;
    public string[] connections;
}